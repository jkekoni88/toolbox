// PoliisiGen ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ keskialueen MAKSIMI 1375 px (FULL). Preview skaalattu tÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤smÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤lleen samasta geometriasta.
  // yritetään hakea manifest.json).
// YhÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ mahdollista lisÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤tÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ paikallisia PNG:itÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œPÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ivitÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ tekstipalkitÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â -napilla.

const W = 1920, H = 1080;
const PREV_W = 960, PREV_H = 540;

const MAX_CONTENT_W = 1375;
const STROKE_PX = 16;
const STROKE_COLOR = '#ffffff';
const MIN_SPLIT_RATIO = 0.1;
const LAYOUTS = [
  { id:'center1', name:'1 kuva' },
  { id:'center2', name:'2 kuvaa' },
  { id:'center3', name:'3 kuvaa' },
];

const $ = (id) => document.getElementById(id);

const els = {
  canvas: $('pgCanvas'),
  downloadBtn: $('downloadBtn'),
  newImageBtn: $('newImageBtn'),

  cellsBar: $('cellsBar'),

  // selected cell controls
  cellFile: $('cellFile'),
  cellClear: $('cellClear'),
  cellCenter: $('cellCenter'),
  resetCell: $('resetCell'),

  cellScale: $('cellScale'),
  cellScaleVal: $('cellScaleVal'),
  cellBright: $('cellBright'),
  cellBrightVal: $('cellBrightVal'),
  cellContrast: $('cellContrast'),
  cellContrastVal: $('cellContrastVal'),

  // layout controls
  contentWidth: $('contentWidth'),
  contentWidthVal: $('contentWidthVal'),
  topPad: $('topPad'),
  topPadVal: $('topPadVal'),
  bottomPad: $('bottomPad'),
  bottomPadVal: $('bottomPadVal'),
  layoutGallery: $('layoutGallery'),

  // frames (tekstipalkit)
  frameFile: $('frameFile'),
  noFrameBtn: $('noFrameBtn'),
  framesList: $('framesList'),
  framesHint: $('framesHint'),
};

const ctx = els.canvas.getContext('2d');

// -------- state --------
function defaultCell(){
  // (poistettu blur & gray)
  return { img:null, iw:0, ih:0, scale:100, offX:0, offY:0, bright:100, contrast:100 };
}
const state = {
  layout: 'center1',        // center1 | center2 | center3
  contentW: MAX_CONTENT_W,  // FULL px
  topPad: 50,               // FULL px
  bottomPad: -16,           // FULL px (negatiivinen piilottaa alareunan stroken)
  gap: 0,                   // sisÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¯ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¿ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â½inen oletus

  selected: 0,
  cells: [defaultCell()],

  bgImg: null,

  // Tekstipalkit
  frames: [],            // { id, name, img, thumb }
  activeFrameIdx: -1,

  splits: {
    center2: 0.5,
    center3: { x: 0.5, y: 0.5 },
  },
};

// -------- helpers --------
function clamp(v,lo,hi){ return Math.min(hi, Math.max(lo, v)); }
function filterString(c){
  const b = clamp(c.bright ?? 100, 0, 200);
  const k = clamp(c.contrast ?? 100, 0, 200);
  return `brightness(${b}%) contrast(${k}%)`;
}

function ensureCellCount(){
  const need = state.layout==='center1' ? 1 : (state.layout==='center2' ? 2 : 3);
  const old = state.cells;
  const next = new Array(need).fill(0).map((_,i)=> old[i] ? { ...defaultCell(), ...old[i] } : defaultCell());
  state.cells = next;
  if (state.selected >= need) state.selected = need - 1;
  renderCellsBar();
  syncCellControls();
}

function renderCellsBar(){
  const n = state.cells.length;
  els.cellsBar.innerHTML = '';
  for (let i=0;i<n;i++){
    const b = document.createElement('button');
    b.className = 'cellchip' + (i===state.selected ? ' active' : '');
    b.type = 'button';
    b.textContent = `Solu ${i+1}`;
    b.addEventListener('click', ()=>{
      state.selected = i;
      renderCellsBar();
      syncCellControls();
      drawPreview();
    });
    els.cellsBar.appendChild(b);
  }
}

function drawLayoutThumb(canvas, layoutId){
  if (!canvas) return;
  const g = canvas.getContext('2d');
  g.clearRect(0,0,canvas.width,canvas.height);
  g.fillStyle = '#0b1220';
  g.fillRect(0,0,canvas.width,canvas.height);

  const pad = 10;
  const area = { x:pad, y:pad, w:canvas.width - pad*2, h:canvas.height - pad*2 };
  const stroke = 8;
  const fills = ['#1d4ed8','#2563eb','#3b82f6'];
  const cells = [];

  if (layoutId === 'center1'){
    cells.push({ ...area });
  } else if (layoutId === 'center2'){
    const leftW = Math.round(area.w * 0.55);
    const rightW = area.w - leftW;
    cells.push(
      { x:area.x, y:area.y, w:leftW, h:area.h },
      { x:area.x + leftW, y:area.y, w:rightW, h:area.h }
    );
  } else {
    const leftW = Math.round(area.w * 0.5);
    const rightW = area.w - leftW;
    const topH = Math.round(area.h * 0.54);
    const bottomH = area.h - topH;
    cells.push(
      { x:area.x, y:area.y, w:leftW, h:area.h },
      { x:area.x + leftW, y:area.y, w:rightW, h:topH },
      { x:area.x + leftW, y:area.y + topH, w:rightW, h:bottomH }
    );
  }

  g.lineJoin = 'round';
  g.lineCap = 'butt';
  cells.forEach((rect, idx)=>{
    g.fillStyle = fills[idx % fills.length];
    g.fillRect(rect.x, rect.y, rect.w, rect.h);
    g.strokeStyle = '#ffffff';
    g.lineWidth = stroke;
    g.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w, rect.h);
  });
}

function renderLayoutGallery(){
  if (!els.layoutGallery) return;
  els.layoutGallery.innerHTML = '';
  LAYOUTS.forEach(layout=>{
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'layout-item';
    btn.dataset.layout = layout.id;

    const cnv = document.createElement('canvas');
    cnv.width = 160; cnv.height = 100;
    cnv.className = 'layout-thumb';
    drawLayoutThumb(cnv, layout.id);

    const label = document.createElement('div');
    label.className = 'layout-name';
    label.textContent = layout.name;

    btn.appendChild(cnv);
    btn.appendChild(label);
    btn.addEventListener('click', ()=>{
      state.layout = layout.id;
      ensureSplitDefaults();
      ensureCellCount();
      syncLayoutButtons();
      drawPreview();
    });

    els.layoutGallery.appendChild(btn);
  });
  syncLayoutButtons();
}

function syncLayoutButtons(){
  if (!els.layoutGallery) return;
  const items = els.layoutGallery.querySelectorAll('.layout-item');
  items.forEach(item=>{
    item.classList.toggle('active', item.dataset.layout === state.layout);
  });
}

function syncLayoutControls(){
  state.contentW = clamp(state.contentW, 0, MAX_CONTENT_W);
  els.contentWidth.value = state.contentW;
  els.contentWidthVal.textContent = `${state.contentW} px`;

  els.topPad.value = state.topPad;
  els.topPadVal.textContent = `${state.topPad} px`;

  els.bottomPad.value = state.bottomPad;
  els.bottomPadVal.textContent = `${state.bottomPad} px`;
}

function syncCellControls(){
  const c = state.cells[state.selected] || defaultCell();
  els.cellScale.value = c.scale; els.cellScaleVal.textContent = `${c.scale}%`;
  els.cellBright.value = c.bright; els.cellBrightVal.textContent = `${c.bright}%`;
  els.cellContrast.value = c.contrast; els.cellContrastVal.textContent = `${c.contrast}%`;
}

function clampSplitRatio(value){
  const num = Number.isFinite(value) ? value : 0.5;
  return clamp(num, MIN_SPLIT_RATIO, 1 - MIN_SPLIT_RATIO);
}

function ensureSplitDefaults(){
  if (!state.splits) state.splits = { center2: 0.5, center3: { x: 0.5, y: 0.5 } };
  if (typeof state.splits.center2 !== 'number') state.splits.center2 = 0.5;
  if (!state.splits.center3 || typeof state.splits.center3 !== 'object'){
    state.splits.center3 = { x: 0.5, y: 0.5 };
  } else {
    if (typeof state.splits.center3.x !== 'number') state.splits.center3.x = 0.5;
    if (typeof state.splits.center3.y !== 'number') state.splits.center3.y = 0.5;
  }
  state.splits.center2 = clampSplitRatio(state.splits.center2);
  state.splits.center3.x = clampSplitRatio(state.splits.center3.x);
  state.splits.center3.y = clampSplitRatio(state.splits.center3.y);
}

// -------- geometry (FULL -> scaled) --------
function computeContentRect(outW, outH){
  const sx = outW / W;
  const sy = outH / H;

  const wFull = clamp(state.contentW, 0, MAX_CONTENT_W);
  const w = Math.round(wFull * sx);

  const yTop = Math.round(clamp(state.topPad, -400, 400) * sy);
  const yBottomPad = Math.round(clamp(state.bottomPad, -400, 400) * sy);

  const x = Math.round((outW - w)/2);
  // korkeus: koko alue miinus ylÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤vÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤li ja miinus alareunan vÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤li (negatiivinen kasvattaa)
  const h = outH - yTop - yBottomPad;

  return { x, y: yTop, w, h };
}

function computeLayoutMeta(outW, outH){
  ensureSplitDefaults();

  const R = computeContentRect(outW, outH);
  const hitPaddingX = Math.max(Math.round(8 * (outW / W)), 6);
  const hitPaddingY = Math.max(Math.round(8 * (outH / H)), 6);

  const rects = [];
  const hitZones = [];
  const dividers = [];

  if (state.layout === 'center1'){
    rects.push({ x:R.x, y:R.y, w:R.w, h:R.h });
  } else if (state.layout === 'center2'){
    const minW = Math.max(Math.round(R.w * MIN_SPLIT_RATIO), 1);
    const ratio = clampSplitRatio(state.splits.center2);
    let leftW = Math.round(R.w * ratio);
    leftW = clamp(leftW, minW, R.w - minW);
    const rightW = R.w - leftW;
    const dividerX = R.x + leftW;

    rects.push(
      { x:R.x, y:R.y, w:leftW, h:R.h },
      { x:dividerX, y:R.y, w:rightW, h:R.h }
    );

    hitZones.push({
      type: 'center2-x',
      axis: 'x',
      x1: dividerX - hitPaddingX,
      x2: dividerX + hitPaddingX,
      y1: R.y - hitPaddingY,
      y2: R.y + R.h + hitPaddingY,
    });
    dividers.push({
      axis: 'x',
      x: dividerX,
      y1: R.y,
      y2: R.y + R.h,
    });
  } else {
    const minW = Math.max(Math.round(R.w * MIN_SPLIT_RATIO), 1);
    const ratioX = clampSplitRatio(state.splits.center3.x);
    let leftW = Math.round(R.w * ratioX);
    leftW = clamp(leftW, minW, R.w - minW);
    const rightW = R.w - leftW;
    const dividerX = R.x + leftW;

    const minH = Math.max(Math.round(R.h * MIN_SPLIT_RATIO), 1);
    const ratioY = clampSplitRatio(state.splits.center3.y);
    let topH = Math.round(R.h * ratioY);
    topH = clamp(topH, minH, R.h - minH);
    const bottomH = R.h - topH;
    const dividerY = R.y + topH;

    rects.push(
      { x:R.x, y:R.y, w:leftW, h:R.h },
      { x:dividerX, y:R.y, w:rightW, h:topH },
      { x:dividerX, y:dividerY, w:rightW, h:bottomH }
    );

    hitZones.push({
      type: 'center3-x',
      axis: 'x',
      x1: dividerX - hitPaddingX,
      x2: dividerX + hitPaddingX,
      y1: R.y - hitPaddingY,
      y2: R.y + R.h + hitPaddingY,
    });
    hitZones.push({
      type: 'center3-y',
      axis: 'y',
      x1: dividerX - hitPaddingX,
      x2: dividerX + rightW + hitPaddingX,
      y1: dividerY - hitPaddingY,
      y2: dividerY + hitPaddingY,
    });
    dividers.push(
      {
        axis: 'x',
        x: dividerX,
        y1: R.y,
        y2: R.y + R.h,
      },
      {
        axis: 'y',
        x1: dividerX,
        x2: dividerX + rightW,
        y: dividerY,
      }
    );
  }

  return { rects, hitZones, contentRect: R, dividers };
}

function computeRects(outW, outH){
  return computeLayoutMeta(outW, outH).rects;
}

function hitTestDivider(px, py){
  const meta = computeLayoutMeta(PREV_W, PREV_H);
  for (const zone of meta.hitZones){
    if (px >= zone.x1 && px <= zone.x2 && py >= zone.y1 && py <= zone.y2){
      return zone;
    }
  }
  return null;
}

function dividerCursor(type){
  return type === 'center3-y' ? 'row-resize' : 'col-resize';
}

function setCanvasCursor(value){
  if (!els.canvas) return;
  els.canvas.style.cursor = value || '';
}

function applyDividerDrag(type, px, py){
  if (!type) return;
  if (type === 'center2-x' && state.layout !== 'center2') return;
  if ((type === 'center3-x' || type === 'center3-y') && state.layout !== 'center3') return;

  const meta = computeLayoutMeta(PREV_W, PREV_H);
  const R = meta.contentRect;

  if (type === 'center2-x' || type === 'center3-x'){
    const pointer = clamp(px, R.x, R.x + R.w);
    const ratio = R.w > 0 ? (pointer - R.x) / R.w : 0.5;
    if (type === 'center2-x') state.splits.center2 = clampSplitRatio(ratio);
    else state.splits.center3.x = clampSplitRatio(ratio);
  } else if (type === 'center3-y'){
    const pointer = clamp(py, R.y, R.y + R.h);
    const ratio = R.h > 0 ? (pointer - R.y) / R.h : 0.5;
    state.splits.center3.y = clampSplitRatio(ratio);
  }

  drawPreview();
}

// -------- draw helpers --------
function drawCellImage(g, cell, rp, rf, isPreview){
  const iw = cell.iw, ih = cell.ih;
  if (!iw || !ih || !cell.img) return;

  const cover = Math.max(rf.w/iw, rf.h/ih);
  const user = cell.scale/100;
  const dW = iw * cover * user;
  const dH = ih * cover * user;

  if (isPreview){
    const sx = PREV_W / W, sy = PREV_H / H;
    const cx = rp.x + rp.w/2 + (cell.offX * sx);
    const cy = rp.y + rp.h/2 + (cell.offY * sy);
    const drawW = dW * sx, drawH = dH * sy;

    g.save();
    g.filter = filterString(cell);
    g.drawImage(cell.img, cx - drawW/2, cy - drawH/2, drawW, drawH);
    g.restore();
  } else {
    const cx = rf.x + rf.w/2 + cell.offX;
    const cy = rf.y + rf.h/2 + cell.offY;

    g.save();
    g.filter = filterString(cell);
    g.drawImage(cell.img, cx - dW/2, cy - dH/2, dW, dH);
    g.restore();
  }
}

function drawStrokeRect(g, r, isPreview){
  g.save();
  g.strokeStyle = STROKE_COLOR;
  g.lineWidth = STROKE_PX * (isPreview ? (PREV_W/W) : 1);
  g.strokeRect(r.x + 0.5, r.y + 0.5, r.w, r.h);
  g.restore();
}

// -------- preview --------
function drawPreview(){
  ctx.clearRect(0,0,PREV_W,PREV_H);

  // tausta
  if (state.bgImg){
    const iw=state.bgImg.width, ih=state.bgImg.height;
    const cover = Math.max(PREV_W/iw, PREV_H/ih);
    const dw = iw * cover, dh = ih * cover;
    ctx.drawImage(state.bgImg, (PREV_W-dw)/2, (PREV_H-dh)/2, dw, dh);
  } else {
    ctx.fillStyle = '#0b3d91';
    ctx.fillRect(0,0,PREV_W,PREV_H);
  }

  const metaPrev = computeLayoutMeta(PREV_W, PREV_H);
  const metaFull = computeLayoutMeta(W, H);
  const rectsPrev = metaPrev.rects;
  const rectsFull = metaFull.rects;
  const placeholderFills = ['rgba(37,99,235,0.25)','rgba(59,130,246,0.25)','rgba(96,165,250,0.25)'];

  // solut
  for (let i=0;i<state.cells.length;i++){
    const cell = state.cells[i];
    const rp = rectsPrev[i];
    const rf = rectsFull[i];

    ctx.save();
    ctx.beginPath(); ctx.rect(rp.x, rp.y, rp.w, rp.h); ctx.clip();
    if (cell?.img) drawCellImage(ctx, cell, rp, rf, true);
    else if (rp){
      ctx.fillStyle = placeholderFills[i % placeholderFills.length];
      ctx.fillRect(rp.x, rp.y, rp.w, rp.h);
    }
    ctx.restore();

    drawStrokeRect(ctx, rp, true);
  }

  // tekstipalkki
  if (state.activeFrameIdx >= 0){
    const fr = state.frames[state.activeFrameIdx];
    if (fr?.img){
      ctx.drawImage(fr.img, 0, 0, PREV_W, PREV_H);
    }
  }

  // valitun solun korostus
  const rpSel = rectsPrev[state.selected];
  if (rpSel){
    ctx.save();
    ctx.strokeStyle = '#ffd400';
    ctx.setLineDash([8,6]);
    ctx.lineWidth = 3;
    ctx.strokeRect(rpSel.x+1, rpSel.y+1, rpSel.w-2, rpSel.h-2);
    ctx.restore();
  }

  // dividerit
  metaPrev.dividers.forEach(div=>{
    ctx.save();
    ctx.strokeStyle = STROKE_COLOR;
    ctx.lineWidth = STROKE_PX * (PREV_W / W);
    ctx.lineCap = 'square';
    if (div.axis === 'x'){
      ctx.beginPath();
      ctx.moveTo(div.x + 0.5, div.y1);
      ctx.lineTo(div.x + 0.5, div.y2);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(div.x1, div.y + 0.5);
      ctx.lineTo(div.x2, div.y + 0.5);
      ctx.stroke();
    }
    ctx.restore();
  });
}

// -------- export --------
function saveBlob(blob, filename){
  const a = document.createElement('a');
  a.download = filename;
  a.href = URL.createObjectURL(blob);
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}
function downloadCanvasPNG(canvas, filename){
  if (canvas.toBlob){
    canvas.toBlob((blob)=>{
      if (blob) return saveBlob(blob, filename);
      try{
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.download = filename; a.href = url; a.click();
      }catch(err){ console.error('Tallennus epÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤onnistui:', err); }
    }, 'image/png', 1.0);
  } else {
    try{
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.download = filename; a.href = url; a.click();
    }catch(err){ console.error('Tallennus epÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤onnistui:', err); }
  }
}

function exportPNG(){
  const out = document.createElement('canvas');
  out.width = W; out.height = H;
  const g = out.getContext('2d');

  // tausta
  if (state.bgImg){
    const iw=state.bgImg.width, ih=state.bgImg.height;
    const cover = Math.max(W/iw, H/ih);
    const dw = iw * cover, dh = ih * cover;
    g.drawImage(state.bgImg, (W-dw)/2, (H-dh)/2, dw, dh);
  } else {
    g.fillStyle = '#0b3d91';
    g.fillRect(0,0,W,H);
  }

  const meta = computeLayoutMeta(W, H);
  const rects = meta.rects;

  // solut
  for (let i=0;i<state.cells.length;i++){
    const r = rects[i];
    const c = state.cells[i];
    g.save();
    g.beginPath(); g.rect(r.x, r.y, r.w, r.h); g.clip();
    if (c?.img) drawCellImage(g, c, r /*unused*/, r, false);
    else if (r){
      g.fillStyle = '#0b3d91';
      g.fillRect(r.x, r.y, r.w, r.h);
    }
    g.restore();

    drawStrokeRect(g, r, false);
  }

  // tekstipalkki
  if (state.activeFrameIdx >= 0){
    const fr = state.frames[state.activeFrameIdx];
    if (fr?.img) g.drawImage(fr.img, 0, 0, W, H);
  }

  meta.dividers.forEach(div=>{
    g.save();
    g.strokeStyle = STROKE_COLOR;
    g.lineWidth = STROKE_PX;
    g.lineCap = 'square';
    if (div.axis === 'x'){
      g.beginPath();
      g.moveTo(div.x + 0.5, div.y1);
      g.lineTo(div.x + 0.5, div.y2);
      g.stroke();
    } else {
      g.beginPath();
      g.moveTo(div.x1, div.y + 0.5);
      g.lineTo(div.x2, div.y + 0.5);
      g.stroke();
    }
    g.restore();
  });

  downloadCanvasPNG(out, 'poliisigen_kuva.png');
}

// -------- interactions --------
let draggingImg = false, draggingDivider = null, lastX=0, lastY=0;

els.canvas.addEventListener('pointerdown', (e)=>{
  const rect = els.canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const dividerZone = hitTestDivider(px, py);
  if (dividerZone){
    draggingDivider = dividerZone.type;
    draggingImg = false;
    setCanvasCursor(dividerCursor(dividerZone.type));
    els.canvas.setPointerCapture(e.pointerId);
    return;
  }

  const rectsPrev = computeRects(PREV_W, PREV_H);
  let hit = -1;
  rectsPrev.forEach((r,i)=>{ if(px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h) hit=i; });
  if (hit>=0) state.selected = hit;
  renderCellsBar();
  syncCellControls();
  drawPreview();

  const selectedCell = state.cells[state.selected];
  if (selectedCell?.img){
    draggingImg = true;
    draggingDivider = null;
    lastX = e.clientX; lastY = e.clientY;
    setCanvasCursor('grabbing');
    els.canvas.setPointerCapture(e.pointerId);
  } else {
    draggingImg = false;
    draggingDivider = null;
    setCanvasCursor('');
  }
});

els.canvas.addEventListener('pointermove', (e)=>{
  const rect = els.canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  if (draggingDivider){
    applyDividerDrag(draggingDivider, px, py);
    setCanvasCursor(dividerCursor(draggingDivider));
    return;
  }

  if (draggingImg){
    const dxp = e.clientX - lastX;
    const dyp = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    const c = state.cells[state.selected];
    if (c){
      c.offX += Math.round(dxp * (W/PREV_W));
      c.offY += Math.round(dyp * (H/PREV_H));
      drawPreview();
    }
    setCanvasCursor('grabbing');
    return;
  }

  const hoverZone = hitTestDivider(px, py);
  if (hoverZone){
    setCanvasCursor(dividerCursor(hoverZone.type));
  } else {
    setCanvasCursor('');
  }
});

['pointerup','pointercancel'].forEach(t=>{
  els.canvas.addEventListener(t, (e)=>{
    draggingImg = false;
    draggingDivider = null;
    try{ els.canvas.releasePointerCapture(e.pointerId);}catch{}

    const rect = els.canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const zone = hitTestDivider(px, py);
    if (zone){
      setCanvasCursor(dividerCursor(zone.type));
    } else {
      setCanvasCursor('');
    }
  });
});

// DnD kuvat suoraan canvakselle
;['dragenter','dragover','dragleave','drop'].forEach(t=>{
  els.canvas.addEventListener(t, e=>e.preventDefault(), false);
});
els.canvas.addEventListener('drop', async (e)=>{
  const file = Array.from(e.dataTransfer.files||[]).find(f=>/image\/(png|jpe?g)/i.test(f.type));
  if (!file) return;
  const rect = els.canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const rectsPrev = computeRects(PREV_W, PREV_H);
  let hit = -1;
  rectsPrev.forEach((r,i)=>{ if(px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h) hit=i; });
  const idx = hit>=0 ? hit : state.selected;
  await loadFileToCell(file, idx);
  state.selected = idx;
  renderCellsBar(); syncCellControls(); drawPreview();
});

// --- selected cell controls
els.cellFile.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; if (!file) return;
  await loadFileToCell(file, state.selected);
  els.cellFile.value = '';
  syncCellControls(); drawPreview();
});
els.cellClear.addEventListener('click', ()=>{
  const i = state.selected;
  state.cells[i] = defaultCell();
  els.cellFile.value='';
  syncCellControls(); drawPreview();
});
els.cellCenter.addEventListener('click', ()=>{
  const c = state.cells[state.selected]; if(!c) return;
  c.offX = 0; c.offY = 0; drawPreview();
});
els.resetCell.addEventListener('click', ()=>{
  const c = state.cells[state.selected]; if(!c) return;
  const keep = { img:c.img, iw:c.iw, ih:c.ih };
  Object.assign(c, defaultCell(), keep);
  syncCellControls(); drawPreview();
});

els.cellScale.addEventListener('input', ()=>{
  const c = state.cells[state.selected]; if(!c) return;
  c.scale = +els.cellScale.value; els.cellScaleVal.textContent = `${c.scale}%`; drawPreview();
});
els.cellBright.addEventListener('input', ()=>{
  const c = state.cells[state.selected]; if(!c) return;
  c.bright = +els.cellBright.value; els.cellBrightVal.textContent = `${c.bright}%`; drawPreview();
});
els.cellContrast.addEventListener('input', ()=>{
  const c = state.cells[state.selected]; if(!c) return;
  c.contrast = +els.cellContrast.value; els.cellContrastVal.textContent = `${c.contrast}%`; drawPreview();
});

// --- layout
});

// --- settings
els.contentWidth.addEventListener('input', ()=>{
  state.contentW = clamp(+els.contentWidth.value, 0, MAX_CONTENT_W);
  els.contentWidthVal.textContent = `${state.contentW} px`;
  drawPreview();
});
els.topPad.addEventListener('input', ()=>{
  state.topPad = +els.topPad.value;
  els.topPadVal.textContent = `${state.topPad} px`;
  drawPreview();
});
els.bottomPad.addEventListener('input', ()=>{
  state.bottomPad = +els.bottomPad.value;
  els.bottomPadVal.textContent = `${state.bottomPad} px`;
  drawPreview();
});

// --- frames (tekstipalkit) ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ MANIFEST + paikallinen lisÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤ys
function renderFramesList(){
  els.framesList.innerHTML = '';
  if (!state.frames.length){
    els.framesHint.style.display = '';
    return;
  }
  els.framesHint.style.display = 'none';
  state.frames.forEach((f, idx)=>{
    const item = document.createElement('button');
    item.type = 'button';
    item.className = 'frame-item' + (idx===state.activeFrameIdx ? ' active':'');
    const img = new Image();
    img.className = 'frame-thumb';
    img.src = f.thumb;
    const name = document.createElement('div');
    name.className = 'frame-name';
    name.textContent = f.name || `Palkki ${idx+1}`;
    item.appendChild(img); item.appendChild(name);
    item.addEventListener('click', ()=>{
      state.activeFrameIdx = idx;
      renderFramesList();
      drawPreview();
    });
    els.framesList.appendChild(item);
  });
}

async function fileToBitmap(file){
  return await createImageBitmap(file);
}
function makeThumb(imgBmp){
  const TW = 200, TH = 112;
  const c = document.createElement('canvas'); c.width=TW; c.height=TH;
  const g = c.getContext('2d');
  g.fillStyle = '#0b1220'; g.fillRect(0,0,TW,TH);
  g.drawImage(imgBmp, 0,0,TW,TH);
  return c.toDataURL('image/png');
}

els.frameFile.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files || []).filter(f=>/image\/png/i.test(f.type));
  if (!files.length) return;
  for (const f of files){
    try{
      const bmp = await fileToBitmap(f);
      const thumb = makeThumb(bmp);
      state.frames.push({ id:f.name, img:bmp, name:f.name.replace(/\.png$/i,''), thumb });
    }catch(_){}
  }
  els.frameFile.value = '';
  if (state.activeFrameIdx < 0 && state.frames.length) state.activeFrameIdx = 0;
  renderFramesList();
  drawPreview();
});
els.noFrameBtn.addEventListener('click', ()=>{
  state.activeFrameIdx = -1;
  renderFramesList(); drawPreview();
});

  // yritetään hakea manifest-lataus ---
async function tryFetchManifestJSON(){
  const candidates = ['/poliisiframes/manifest.json', 'poliisiframes/manifest.json'];
  for (const url of candidates){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if (res.ok) return await res.json();
    }catch(_){}
  }
  return null;
}
async function populateFramesFromList(entries){
  state.frames = [];
  for (const entry of entries){
    const file = entry?.file;
    if (!file || !/\.png$/i.test(file)) continue;

    const name = entry?.name || entry?.id || file.replace(/\.png$/i,'');
    const urls = [`/poliisiframes/${file}`, `poliisiframes/${file}`];

    let imgRes = null;
    for (const u of urls){
      try{
        const r = await fetch(u, { cache: 'no-store' });
        if (r.ok){ imgRes = r; break; }
      }catch(_){}
    }
    if (!imgRes) continue;

    const blob = await imgRes.blob();
    const bmp = await createImageBitmap(blob);
    const thumb = makeThumb(bmp);
    state.frames.push({ id: entry.id || file, name, img:bmp, thumb });
  }
  if (state.frames.length && state.activeFrameIdx < 0) state.activeFrameIdx = 0;
  renderFramesList();
  drawPreview();
}
async function loadFramesFromManifest(){
  if (!els.framesHint) return;
  els.framesHint.style.display = '';
  els.framesHint.textContent = 'Haetaan tekstipalkkejaÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦';

  const list = await tryFetchManifestJSON();
  if (!list){
    els.framesHint.style.display = '';
    els.framesHint.textContent = 'Tekstipalkkien haku ei onnistunut.';
    return false;
  }
  await populateFramesFromList(list);
  if (!state.frames.length){
    els.framesHint.style.display = '';
    els.framesHint.textContent = 'Tekstipalkkien haku ei onnistunut.';
    return false;
  }
  els.framesHint.style.display = 'none';
  return true;
}

// --- new / download
els.newImageBtn.addEventListener('click', ()=>{
  state.cells = state.cells.map(()=>defaultCell());
  state.selected = 0;
  renderCellsBar(); syncCellControls(); drawPreview();
});
els.downloadBtn.addEventListener('click', exportPNG);

// --- load bg
(function loadBackground(){
  const img = new Image();
  img.crossOrigin = 'anonymous'; // varmuuden vuoksi
  img.onload = ()=>{ state.bgImg = img; drawPreview(); };
  img.onerror = ()=>{ state.bgImg = null; drawPreview(); };
  img.src = 'img/poliisigen_tausta.jpg';
})();

// --- load to cell
async function loadFileToCell(file, index){
  try{
    const bmp = await createImageBitmap(file);
    state.cells[index] = { ...defaultCell(), img:bmp, iw:bmp.width, ih:bmp.height };
  }catch(err){ console.error('Kuvan lataus epÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¤onnistui:', err); }
}

// --- start
async function start(){
  ensureSplitDefaults();
  renderLayoutGallery();
  ensureCellCount();
  syncLayoutControls();
  renderFramesList();
  renderCellsBar();
  syncCellControls();
  drawPreview();
  // yritetään hakea manifest
  await loadFramesFromManifest();
}
window.addEventListener('DOMContentLoaded', start);


